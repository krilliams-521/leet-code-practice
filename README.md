| #     | Problem                             | Core Pattern                            | Key Data Structures                 | Time Complexity | Description                                                                                                          |
| ----- | ----------------------------------- | --------------------------------------- | ----------------------------------- | --------------- | -------------------------------------------------------------------------------------------------------------------- |
| **1** | **Two Sum**                         | ðŸ§© **Hash Map / Hashing**               | Hash map (`{ number â†’ index }`)     | **O(n)**        | Use a map for constant-time lookups of complements. This is a classic hashing pattern for fast element lookup.       |
| **2** | **Valid Parentheses**               | ðŸ§± **Stack**                            | Stack (array used as LIFO)          | **O(n)**        | Use a stack to track open brackets and match them with closing ones â€” the textbook stack pattern.                    |
| **3** | **Merge Two Sorted Linked Lists**   | ðŸ”— **Linked List / Two Pointers**       | Linked list nodes                   | **O(n + m)**    | Traverse both lists with pointers and build a new merged list. This is a two-pointer merge pattern.                  |
| **4** | **Best Time to Buy and Sell Stock** | ðŸ“‰ **Sliding Window / One-Pass Greedy** | Variables (`minPrice`, `maxProfit`) | **O(n)**        | Maintain the lowest price so far and the max profit. This is a greedy one-pass optimization problem.                 |
| **5** | **Valid Palindrome**                | ðŸ”„ **Two Pointers**                     | Pointers (indices)                  | **O(n)**        | Move inward from both ends, comparing characters. This is a two-pointer scanning technique.                          |
| **6** | **Invert Binary Tree**              | ðŸŒ² **Recursion / Tree Traversal (DFS)** | Binary tree nodes                   | **O(n)**        | Recursively swap the left and right children of each node, then repeat for both subtrees. Each node is visited once. |
| **7** | **Valid Anagram**                   | ðŸ”  **Hash Map / Frequency Counting**    | Object / Hash map (`{ char â†’ count }`) | **O(n)**     | Count character frequencies in the first string, then decrement while scanning the second. Return false if mismatched. |

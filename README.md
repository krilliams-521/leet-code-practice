| #     | Problem                             | Core Pattern                            | Key Data Structures                           | Time Complexity | Description                                                                                                            |
| ----- | ----------------------------------- | --------------------------------------- | --------------------------------------------- | --------------- | ---------------------------------------------------------------------------------------------------------------------- |
| **1** | **Two Sum**                         | ğŸ§© **Hash Map / Hashing**               | Hash map (`{ number â†’ index }`)               | **O(n)**        | Use a map for constant-time lookups of complements. This is a classic hashing pattern for fast element lookup.         |
| **2** | **Valid Parentheses**               | ğŸ§± **Stack**                            | Stack (array used as LIFO)                    | **O(n)**        | Use a stack to track open brackets and match them with closing ones â€” the textbook stack pattern.                      |
| **3** | **Merge Two Sorted Linked Lists**   | ğŸ”— **Linked List / Two Pointers**       | Linked list nodes                             | **O(n + m)**    | Traverse both lists with pointers and build a new merged list. This is a two-pointer merge pattern.                    |
| **4** | **Best Time to Buy and Sell Stock** | ğŸ“‰ **Sliding Window / One-Pass Greedy** | Variables (`minPrice`, `maxProfit`)           | **O(n)**        | Maintain the lowest price so far and the max profit. This is a greedy one-pass optimization problem.                   |
| **5** | **Valid Palindrome**                | ğŸ”„ **Two Pointers**                     | Pointers (indices)                            | **O(n)**        | Move inward from both ends, comparing characters. This is a two-pointer scanning technique.                            |
| **6** | **Invert Binary Tree**              | ğŸŒ² **Recursion / Tree Traversal (DFS)** | Binary tree nodes                             | **O(n)**        | Recursively swap the left and right children of each node, then repeat for both subtrees. Each node is visited once.   |
| **7** | **Valid Anagram**                   | ğŸ”  **Hash Map / Frequency Counting**    | Object / Hash map (`{ char â†’ count }`)        | **O(n)**        | Count character frequencies in the first string, then decrement while scanning the second. Return false if mismatched. |
| **8** | **Binary Search**                   | ğŸ¯ **Divide and Conquer / Two Pointers**| Sorted array with `left`, `right`, `mid` indices | **O(log n)**   | Repeatedly halve the search space by comparing the middle element to the target. Ideal for sorted arrays.              |
| **9** | **Flood Fill**                      | ğŸŒŠ **Depth-First Search (DFS)**         | 2D grid (matrix)                              | **O(m Ã— n)**    | Recursively fill connected cells that share the same original color. Classic flood-fill recursion pattern.             |
| **10**| **Lowest Common Ancestor (BST)**    | ğŸ§­ **Binary Search Tree Traversal**     | Binary search tree nodes                      | **O(h)**        | Traverse down the tree using BST properties. The split point (where `p` and `q` diverge) is the lowest common ancestor.|
| **11**| **Balanced Binary Tree**            | âš–ï¸ **Recursion / Post-Order DFS**       | Binary tree nodes                             | **O(n)**        | Compute subtree heights bottom-up. Return `-1` if imbalance exceeds 1 to short-circuit recursion early.                |

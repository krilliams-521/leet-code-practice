| #      | Problem                             | Core Pattern                               | Key Data Structures                              | Time Complexity    | Description                                                                                          |
| ------ | ----------------------------------- | ------------------------------------------ | ------------------------------------------------ | ------------------ | ---------------------------------------------------------------------------------------------------- |
| **1**  | **Two Sum**                         | ğŸ§© **Hash Map / Hashing**                  | Hash map (`{ number â†’ index }`)                  | **O(n)**           | Use a map for constant-time lookups of complements. Classic hashing pattern for fast element lookup. |
| **2**  | **Valid Parentheses**               | ğŸ§± **Stack**                               | Stack (array used as LIFO)                       | **O(n)**           | Push open brackets, pop when matching close brackets. Valid if stack empties.                        |
| **3**  | **Merge Two Sorted Linked Lists**   | ğŸ”— **Linked List / Two Pointers**          | Linked list nodes                                | **O(n + m)**       | Traverse both lists with pointers and build a merged list. Classic two-pointer merge pattern.        |
| **4**  | **Best Time to Buy and Sell Stock** | ğŸ“‰ **Sliding Window / One-Pass Greedy**    | Variables (`minPrice`, `maxProfit`)              | **O(n)**           | Track the lowest price so far and the best profit seen. One-pass optimization.                       |
| **5**  | **Valid Palindrome**                | ğŸ”„ **Two Pointers**                        | Pointers (indices)                               | **O(n)**           | Check characters from both ends inward while skipping non-alphanumerics.                             |
| **6**  | **Invert Binary Tree**              | ğŸŒ² **Recursion / Tree Traversal (DFS)**    | Binary tree nodes                                | **O(n)**           | Swap left/right children at each node recursively. Each node visited once.                           |
| **7**  | **Valid Anagram**                   | ğŸ”  **Hash Map / Frequency Counting**       | Object / Hash map (`{ char â†’ count }`)           | **O(n)**           | Count char frequencies in `s`, decrement with `t`. Return false if mismatch.                         |
| **8**  | **Binary Search**                   | ğŸ¯ **Divide and Conquer / Two Pointers**   | Sorted array with `left`, `right`, `mid` indices | **O(log n)**       | Halve the search space repeatedly based on comparison with mid element.                              |
| **9**  | **Flood Fill**                      | ğŸŒŠ **Depth-First Search (DFS)**            | 2D grid (matrix)                                 | **O(m Ã— n)**       | DFS to recolor connected cells of the same original color. Classic flood-fill pattern.               |
| **10** | **Lowest Common Ancestor (BST)**    | ğŸ§­ **Binary Search Tree Traversal**        | Binary search tree nodes                         | **O(h)**           | Move left or right based on BST property. The split point is the LCA.                                |
| **11** | **Balanced Binary Tree**            | âš–ï¸ **Recursion / Post-Order DFS**          | Binary tree nodes                                | **O(n)**           | Compute subtree heights bottom-up. Return -1 on imbalance to exit early.                             |
| **12** | **Linked List Cycle**               | ğŸ¢ğŸ‡ **Two Pointers (Floydâ€™s Cycle Find)** | Linked list nodes                                | **O(n)**           | Use slow/fast pointers. If they meet, there's a cycle. Fast catches slow only if a loop exists.      |
| **13** | **Implement Queue Using Stacks**    | ğŸ¥ **Two Stacks**                          | Two stacks (`in`, `out`)                         | **Amortized O(1)** | Push to `in`. Pop/peek from `out`. Transfer from `in` â†’ `out` only when needed. Queue via two LIFOs. |
| **14** | **First Bad Version**               | ğŸ§ª **Binary Search / Predicate Check**     | Versions 1 â†’ n, isBadVersion()                   | **O(log n)**       | Binary search on predicate. Narrow search space until left = right â†’ first bad version.              |
| **15** | **Ransom Note**                     | ğŸ§© **Hash Map / Frequency Counting**       | Object / Hash map (`{ char â†’ count }`)           | **O(m + n)**       | Count magazine chars, decrement for ransomNote. Return false if any char runs out.                  |
| **16** | **Climbing Stairs**                 | ğŸ”¢ **Dynamic Programming (Fibonacci)**     | Variables (`first`, `second`)                    | **O(n)**           | DP: ways(n) = ways(n-1) + ways(n-2). Space-optimized Fibonacci approach.                            |

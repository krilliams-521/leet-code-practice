| #     | Problem                                   | Core Pattern                              | Key Data Structures                     | Time Complexity | Description                                                                                                                |
| ----- | ----------------------------------------- | ----------------------------------------- | --------------------------------------- | --------------- | -------------------------------------------------------------------------------------------------------------------------- |
| **1** | **Two Sum**                               | ðŸ§© **Hash Map / Hashing**                 | Hash map (`{ number â†’ index }`)         | **O(n)**        | Use a map for constant-time lookups of complements. This is a classic hashing pattern for fast element lookup.             |
| **2** | **Valid Parentheses**                     | ðŸ§± **Stack**                              | Stack (array used as LIFO)              | **O(n)**        | Use a stack to track open brackets and match them with closing ones â€” the textbook stack pattern.                          |
| **3** | **Merge Two Sorted Linked Lists**         | ðŸ”— **Linked List / Two Pointers**         | Linked list nodes                       | **O(n + m)**    | Traverse both lists with pointers and build a new merged list. This is a two-pointer merge pattern.                        |
| **4** | **Best Time to Buy and Sell Stock**       | ðŸ“‰ **Sliding Window / One-Pass Greedy**   | Variables (`minPrice`, `maxProfit`)     | **O(n)**        | Maintain the lowest price so far and the max profit. This is a greedy one-pass optimization problem.                       |
| **5** | **Valid Palindrome**                      | ðŸ”„ **Two Pointers**                       | Pointers (indices)                      | **O(n)**        | Move inward from both ends, comparing characters. This is a two-pointer scanning technique.                                |
| **6** | **Invert Binary Tree**                    | ðŸŒ² **Recursion / Tree Traversal (DFS)**   | Binary tree nodes                       | **O(n)**        | Recursively swap the left and right children of each node, then repeat for both subtrees. Each node is visited once.       |
| **7** | **Valid Anagram**                         | ðŸ”  **Hash Map / Frequency Counting**      | Object / Hash map (`{ char â†’ count }`)  | **O(n)**        | Count character frequencies in the first string, then decrement while scanning the second. Return false if mismatched.     |
| **8** | **Binary Search**                         | ðŸŽ¯ **Divide and Conquer / Two Pointers**  | Sorted array with `left`, `right`, `mid` indices | **O(log n)**   | Repeatedly halve the search space by comparing the middle element to the target. Ideal for sorted arrays.                  |
| **9** | **Flood Fill**                            | ðŸŒŠ **DFS (Depth-First Search)**           | 2D grid (matrix of pixels)              | **O(n Ã— m)**    | Recursively fill all connected pixels of the same color using DFS while checking boundaries.                               |
| **10** | **Lowest Common Ancestor (BST)**          | ðŸŒ³ **Binary Search Tree Traversal**       | Binary tree nodes (with left/right)     | **O(h)**        | Traverse the BST from the root: move left or right depending on node values until the split point â€” the lowest common ancestor. |
